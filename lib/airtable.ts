import Airtable from "airtable";
import { getUserInfo } from "./auth";
import { projectReviewMessage } from "./bot";

function getBase() {
  if (!process.env.AIRTABLE_API_KEY) {
    throw new Error("AIRTABLE_API_KEY is required");
  }
  if (!process.env.AIRTABLE_BASE_ID) {
    throw new Error("AIRTABLE_BASE_ID is required");
  }
  return new Airtable({ apiKey: process.env.AIRTABLE_API_KEY }).base(
    process.env.AIRTABLE_BASE_ID
  );
}

function getUsersTable() {
  return getBase()(process.env.AIRTABLE_TABLE_NAME || "Users");
}

export async function getUserFromId(userid: string) {
  const safeId = escapeFormulaString(userid);
  const user = await getUsersTable().select({
    filterByFormula: `{id} = '${safeId}'`,
    maxRecords: 1,
  })
  .firstPage();
  return user[0]
}

export async function getAllUsers() {
  const users = await getUsersTable()
    .select({
      view: "Grid view"
    })
    .all();

  return users.map((user) => ({
    id: user.get("id") as string,
    slack_id: user.get("slack_id") as string,
  }));
}

function getFulfillmentTable() {
  return getBase()("FULFILLMENT");
}


export function getProjectsTable() {
  return getBase()("projects");
}

export function getProductsTable() {
  return getBase()("shop");
}

export function getShopTable() {
  return getBase()("user_shop_info");
}

export function getDevlogsTable() {
  return getBase()("devlogs");
}

//YSWS database
function getReviewTable() {
  return getBase()("YSWS Project Submission");
}

export async function getSingularProject(userid: string, name: string) {
  const safeUserId = escapeFormulaString(userid);
  const safeName = escapeFormulaString(name);
  const record = await getProjectsTable()
    .select({
      filterByFormula: `AND({userid} = '${safeUserId}', {name} = '${safeName}')`,
      view: "Grid view",
    })
    .firstPage();

  return record[0];
}

export async function getProjectById(projectId: string) {
  const record = await getProjectsTable().find(projectId);
  return {
    id: record.id,
    name: record.get("name") as string,
    desc: record.get("desc") as string,
    hours: record.get("hours") as number,
    hackatime_name: record.get("hackatime_name") as string,
    userid: record.get("userid") as string,
  };
}

export async function updateProjectHours(projectid: string, hours: number) {
  return await getProjectsTable().update([
    {
      "id": projectid,
      "fields": {
        "hours": hours
      }
    }])
}

export async function updateProjectName(projectid: string, name: string) {
  if (typeof name !== "string" || name.length > 200) {
    throw new Error("Invalid name: must be a string under 200 characters");
  }
  const record = await getProjectsTable().update([
    {
      "id": projectid,
      "fields": {
        "name": name
      }
    }])
  return record[0];
}

export async function updateProjectDesc(projectid: string, desc: string) {
  if (typeof desc !== "string" || desc.length > 5000) {
    throw new Error("Invalid description: must be a string under 5000 characters");
  }
  const record = await getProjectsTable().update([
    {
      "id": projectid,
      "fields": {
        "desc": desc
      }
    }])
  return record[0];
}

export async function updateProjectHackatime(projectid: string, hackatime_name: string) {
  const record = await getProjectsTable().update([
    {
      "id": projectid,
      "fields": {
        "hackatime_name": hackatime_name
      }
    }])
  return record[0];
}

export async function getUsersProjects(userid: string) {
  const safeId = escapeFormulaString(userid);
  const records = await getProjectsTable()
  .select({
    filterByFormula: `{userid} = '${safeId}'`,
    view: "Grid view"
}).all()

  const projects = records.map((r) => ({
    id: r.id,
    name: r.get("name") as string,
    desc: r.get("description") as string,
    hours: r.get("hours") as Number,
    status: r.get("status") as string,
    hackatime_name: r.get("hackatime_name") as string,
  }));

  return projects || [];
}

export interface UserRecord {
  id: string;
  email: string;
  name?: string;
  slack_id?: string;
  slack_display_name?: string;
  slack_avatar_url?: string;
  verification_status?: string;
  utm_source?: string;
  created_at: string;
}

function escapeFormulaString(value: string): string {
  return value.replace(/\\/g, "\\\\").replace(/'/g, "\\'");
}

export async function findUserByEmail(email: string) {
  const safeEmail = escapeFormulaString(email);
  const records = await getUsersTable()
    .select({
      filterByFormula: `{email} = '${safeEmail}'`,
      maxRecords: 1,
    })
    .firstPage();

  return records[0] || null;
}

export async function createUser(user: Omit<UserRecord, "created_at">) {
  const fields: Record<string, string> = {
    id: user.id,
    email: user.email,
    name: user.name || "",
    slack_id: user.slack_id || "",
    slack_display_name: user.slack_display_name || "",
    slack_avatar_url: user.slack_avatar_url || "",
    verification_status: user.verification_status || "",
    utm_source: user.utm_source || "",
    created_at: new Date().toISOString(),
  };

  const record = await getUsersTable().create(fields);
  return record;
}

export async function updateUser(
  recordId: string,
  updates: Partial<UserRecord>
) {
  const record = await getUsersTable().update(recordId, updates);
  return record;
}

export async function getShopItems() {
  const records = await getProductsTable()
    .select({
      view: "Grid view",
    })
    .all();

  return records.map((r) => ({
    id: r.id,
    name: r.get("item_friendly_name") as string,
    description: r.get("description") as string,
    price: r.get("price") as number,
    image: r.get("image") as string | undefined,
    availability: r.get("availability") as string | undefined,
  }));
}

export async function getCurrency(userid: string) {
  const safeId = escapeFormulaString(userid);
  const records = await getShopTable()
    .select({
      filterByFormula: `{id} = '${safeId}'`,
      maxRecords: 1,
    })
    .firstPage();

    return records[0]?.get("currency") ?? 0
}

export async function addProduct(userid: string, product: string) {
  const safeUserId = escapeFormulaString(userid);
  const safeProduct = escapeFormulaString(product);

  const records = await getShopTable()
    .select({
      filterByFormula: `{id} = '${safeUserId}'`,
      maxRecords: 1,
    })
    .firstPage();

    const product_records = await getProductsTable()
    .select({
      filterByFormula: `{id} = '${safeProduct}'`,
      maxRecords: 1,
    })
    .firstPage();

  if (!records.length) throw new Error(`No record found for userid=${userid}`);

  const record = records[0];
  const product_record = product_records[0];

  const currentOrdered = (record.get("ordered") as string[]) ?? [];
  // Only add the product if it's not already in the array to avoid duplicates
  const updatedOrdered = currentOrdered.includes(product)
    ? currentOrdered
    : [...currentOrdered, product];

  const currentCurrency = (record.get("currency") as number) ?? 0;
  const updatedCurrency = currentCurrency - Number(product_record.get("price"))

  await getShopTable().update([
    {
      id: record.id,
      fields: {
        ordered: updatedOrdered,
        currency: updatedCurrency,
      },
    },
  ]);

  addFulfillment(userid, product)

  return "success";
}

export async function hasUserOrderedProduct(userid: string, product: string): Promise<boolean> {
  const safeUserId = escapeFormulaString(userid);
  
  const records = await getShopTable()
    .select({
      filterByFormula: `{id} = '${safeUserId}'`,
      maxRecords: 1,
    })
    .firstPage();

  if (!records.length) return false;

  const currentOrdered = (records[0].get("ordered") as string[]) ?? [];
  return currentOrdered.includes(product);
}

export async function addFulfillment(userid: string, product: string) {
  const safeUserId = escapeFormulaString(userid);
  const user = await getUsersTable().select({
    filterByFormula: `{id} = '${safeUserId}'`,
    maxRecords: 1,
  })
  .firstPage();

  const date = new Date().toISOString().slice(0, 10);

  const fields = {
    user: [user[0].getId()],
    product: [product],
    date: date,
    status: "Unfulfilled",
  };

  const records = await getFulfillmentTable().create([
    {
      fields,
    },
  ]);

  return records[0];
}

export async function getUserOrders(userid: string) {
  const safeUserId = escapeFormulaString(userid);
  const users = await getUsersTable().select({
    filterByFormula: `{id} = '${safeUserId}'`,
    maxRecords: 1,
  })
  .firstPage();

  if (!users.length) return [];

  const user = users[0];
  const userRecordId = user.getId();

  // Fetch all records and filter manually since Airtable formulas don't work well with linked record arrays
  const allRecords = await getFulfillmentTable()
    .select({
      sort: [{ field: "date", direction: "desc" }],
    })
    .all();

  // Filter records where the user field array contains the userRecordId
  const records = allRecords.filter(r => {
    const userField = r.get("user") as string[];
    if (Array.isArray(userField)) {
      return userField.includes(userRecordId);
    }
    return userField === userRecordId;
  });

  const ordersWithDetails = await Promise.all(
    records.map(async (r) => {
      const productIds = r.get("product") as string[];
      const productId = productIds?.[0];

      let productDetails = null;
      if (productId) {
        try {
          const productRecord = await getProductsTable().find(productId);
          productDetails = {
            name: productRecord.get("item_friendly_name") as string,
            price: productRecord.get("price") as number,
            image: productRecord.get("image") as string | undefined,
          };
        } catch (err) {
          console.error("Failed to fetch product details:", err);
        }
      }

      const address = {
        line1: String(user.get("Address (Line 1)") || ""),
        line2: String(user.get("Address (Line 2)") || ""),
        city: String(user.get("City (from Hack Clubbers)") || ""),
        state: String(user.get("State (from Hack Clubbers)") || ""),
        country: String(user.get("Country (from Hack Clubbers)") || ""),
        zip: String(user.get("ZIP (from Hack Clubbers)") || ""),
      };

      return {
        id: r.id,
        date: r.get("date") as string,
        status: r.get("status") as string,
        product: productDetails,
        productId: productId,
        address,
      };
    })
  );

  return ordersWithDetails;
}

export async function createDevlogEntry(projectId: string, date: string, text: string) {
  if (typeof text !== "string" || text.length > 10000) {
    throw new Error("Invalid text: must be a string under 10000 characters");
  }
  const fields = {
    project: [projectId],
    date: date,
    text: text,
  };

  const record = await getDevlogsTable().create(fields);
  return record;
}

export async function updateDevlogEntry(devlogId: string, text: string) {
  if (typeof text !== "string" || text.length > 10000) {
    throw new Error("Invalid text: must be a string under 10000 characters");
  }
  const record = await getDevlogsTable().update(devlogId, {
    text: text,
  });
  return record;
}

export async function getProjectDevlogs(projectId: string) {
  const records = await getDevlogsTable()
    .select({
      sort: [{ field: "date", direction: "desc" }],
    })
    .all();

  // Filter manually in JavaScript
  const filtered = records.filter(r => {
    const projField = r.get("project");
    if (Array.isArray(projField)) {
      return projField.includes(projectId);
    }
    return projField === projectId;
  });

  return filtered.map((r) => ({
    id: r.id,
    date: r.get("date") as string,
    text: r.get("text") as string,
  }));
}

export async function shipProjectTable(projectid: string, info: any) {
  
  getProjectsTable().update([
    {
      "id": projectid,
      "fields": {
        "status": "Shipped"
      }
    }])

    const safeProjectId = escapeFormulaString(projectid);
    const record = await getProjectsTable()
    .select({
      filterByFormula: `{id} = '${safeProjectId}'`,
      maxRecords: 1,
    })
    .firstPage();
    
    const project = record[0]

    const userid = await project.get("userid")
    var user;

    if (userid) {
      const safeUserId = escapeFormulaString(String(userid));
      user = (await getUsersTable()
      .select({
        filterByFormula: `{id} = '${safeUserId}'`,
        maxRecords: 1,
      })
      .firstPage())[0]
    }

    if (user) {
      //fields
    const fields: Record<any, any> = {
      "First Name": info.firstName || String(user.get("First Name")),
      "Last Name": info.lastName || String(user.get("Last Name")),
      "Email": info.email || user.get("email"),
      "Description": project.get("desc"),
      "GitHub Username": info.github,
      "Address (Line 1)": info.address1 || String(user.get("Address (Line 1)")),
      "Address (Line 2)": info.address2 || String(user.get("Address (Line 2)")),
      "City": info.city || String(user.get("City (from Hack Clubbers)")),
      "State / Province": info.state || String(user.get("State (from Hack Clubbers)")),
      "Country": info.country || String(user.get("Country (from Hack Clubbers)")),
      "ZIP / Postal Code": info.zip || String(user.get("ZIP (from Hack Clubbers)")),
      "Birthday": info.birthdate ? new Date(info.birthdate) : new Date(String(user.get("Birthday (from Hack Clubbers)"))),
      "Playable URL": info.playable_url,
      "Code URL": info.code_url,
      "userid": user.get("id"),
      "displayname": user.get("slack_display_name"),
      "Project": project.get("name"),
      "YSWS": info.ysws,
      "Challenge": info.challenge,
      "hours": project.get("hours"),
    };
  
    const review = await getReviewTable().create(fields);

    if (info.screenshot instanceof File) {
      await uploadAttachment({
        baseId: process.env.AIRTABLE_BASE_ID!,
        recordId: review.getId(),       // IMPORTANT
        fieldNameOrId: "Screenshot",        // exact field name
        file: info.screenshot,
      })
    }

    //send dm
    projectReviewMessage(user.get("email"), "Congrats on shipping your project for Sleepover! Your project will be reviewed soon, and any status updates will be sent here.")
    
    return review
    }
}

export async function getProgressHours(userid: string) {
  const safeId = escapeFormulaString(userid);
  const user = await getShopTable().select({
    filterByFormula: `{id} = '${safeId}'`,
    maxRecords: 1,
  })
  .firstPage();

  return user[0]?.get("hours_shipped") ?? 0
}

const MAX_UPLOAD_SIZE = 5 * 1024 * 1024; // 5MB
const ALLOWED_IMAGE_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];

async function uploadAttachment({
  baseId,
  recordId,
  fieldNameOrId, // "screenshot" or "fldXXXXXXXX"
  file,
}: {
  baseId: string
  recordId: string
  fieldNameOrId: string
  file: File
}) {
  // Validate file size
  if (file.size > MAX_UPLOAD_SIZE) {
    throw new Error("File exceeds maximum size of 5MB")
  }

  // Validate file type
  if (!ALLOWED_IMAGE_TYPES.includes(file.type)) {
    throw new Error("Invalid file type. Only images (JPEG, PNG, GIF, WebP) are allowed.")
  }

  // Convert File -> base64
  const arrayBuffer = await file.arrayBuffer()
  const base64 = Buffer.from(arrayBuffer).toString("base64")

  const url = `https://content.airtable.com/v0/${baseId}/${recordId}/${fieldNameOrId}/uploadAttachment`

  const res = await fetch(url, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${process.env.AIRTABLE_API_KEY}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      contentType: file.type || "application/octet-stream",
      filename: file.name || "upload",
      file: base64,
    }),
  })

  const text = await res.text()
  if (!res.ok) {
    throw new Error(`Airtable upload failed (${res.status}): ${text}`)
  }
  return JSON.parse(text)
}

//CACHING STUFF

import { unstable_cache } from "next/cache";

export const getProjectsCached = unstable_cache(
  async (userId: string) => getUsersProjects(userId),
  ["projects-by-user"],
  { revalidate: 60, tags: ["projects"] }
);

export const getUserHoursCached = unstable_cache(
  async (userId: string) => getProgressHours(userId),
  ["user-hours-by-user"],
  { revalidate: 60, tags: ["user-hours"] }
);

export async function getGallery() {
  const records = await getReviewTable()
    .select({
      filterByFormula: `{Status} = 'Approved'`,
    })
    .all();
    return records
}